<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Randomized Algorithms</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            font-family: 'Times New Roman', Times, serif;
            background-color: #f4f4f9;
        }
        h1 {
            text-align: center;
            margin-top: 20px;
        }
        h2 {
            align-self: flex-start;
            margin-left: 20px;
        }
        p, ul {
            align-self: flex-start;
            margin-left: 20px;
            margin-right: 20px;
        }
        ul {
            list-style: disc;
        }
        li {
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <h1>Randomized Algorithms</h1>

    <h2>Introduction</h2>
    <p>A randomized algorithm is an algorithm that uses random numbers or random choices as part of its logic to solve a computational problem. The randomness introduced can affect the behaviour, runtime, or output of the algorithm, depending on the specific application. Randomized algorithms where randomness is induced in the output of the algorithm are often used for primality checking. Such a class of algorithms having randomness in the output are called Monte Carlo Algorithms.</p>
    <p>Prime numbers are a fascinating and essential part of mathematics. There are several mysteries in mathematics involving prime numbers. At the same time, prime numbers have varied practical applications in mathematics and computer science. Thus, given a number, it is essential to know whether it is prime or not. Now, factoring large numbers is not an easy task. There is no known algorithm that can factorize all integers in polynomial time. (Although the existence or non-existence of such an algorithm has not yet been proved.) This is where randomized algorithms come in. Randomized algorithms are useful in primality checks because they offer efficiency and probabilistic guarantees for large numbers. They often have polynomial runtime. One such algorithm is the Solovay-Strassen Primality Test. Before we go into the algorithm, I would like to give some short notes on prerequisites to understand the algorithm.</p>

    <h2>Table of Contents</h2>
    <ul>
        <li><a href="#modular-arithmetic">Modular Arithmetic</a></li>
        <li><a href="#eulers-totient">Euler's Totient Function</a></li>
        <li><a href="#groups">Groups</a></li>
        <li><a href="#generators">Generators</a></li>
        <li><a href="#quadratic-residue">Quadratic Residue</a></li>
        <li><a href="#legendre-symbol">Legendre Symbol</a></li>
        <li><a href="#jacobi-symbol">Jacobi Symbol</a></li>
        <li><a href="#algorithm-analysis">The Algorithm and Its Analysis</a></li>
    </ul>

    <h2 id="modular-arithmetic">Modular Arithmetic</h2>
    <p>We use the notation \( a \equiv b \pmod{n} \) to denote the fact that \( n \mid (a - b) \). So \( b \) essentially gives us a remainder.</p>
    <p>Some properties of modular arithmetic:</p>
    <ul>
        <li>\( a \equiv a \pmod{n} \)</li>
        <li>If \( a \equiv b \pmod{n} \), then \( b \equiv a \pmod{n} \)</li>
        <li>If \( a \equiv b \pmod{n} \) and \( b \equiv c \pmod{n} \), then \( a \equiv c \pmod{n} \)</li>
        <li>If \( a \equiv b \pmod{n} \) and \( c \equiv d \pmod{n} \), then \( a + c \equiv b + d \pmod{n} \) and \( ac \equiv bd \pmod{n} \)</li>
        <li>If \( a \equiv b \pmod{n} \), then \( a + c \equiv b + c \pmod{n} \) and \( ac \equiv bc \pmod{n} \)</li>
        <li>If \( a \equiv b \pmod{n} \), then \( a^k \equiv b^k \pmod{n} \) for any positive integer \( k \)</li>
        <li>If \( ca \equiv cb \pmod{n} \) and \( \gcd(c, n) = 1 \), then \( a \equiv b \pmod{n} \)</li>
    </ul>
    <p>One can easily verify these using basic concepts of divisibility of integers.</p>

    <h2 id="eulers-totient">Euler's Totient Function</h2>
    <p>The Euler's totient function \( \phi(n) \) denotes the cardinality of the set \( \{x \mid 1 \leq x < n, x \in \mathbb{N}, \gcd(x, n) = 1\} \).</p>
    <p>For \( p^k \), where \( p \) is a prime and \( k \) is a positive integer, \( p^k \) is not co-prime to \( 1, p, 2p, \dots, p^{k-1}p \), which accounts for \( p^{k-1} \) numbers. Thus, \( \phi(p^k) = p^k - p^{k-1} \).</p>
    <p><strong>Euler's Theorem:</strong> If \( \gcd(a, n) = 1 \), then \( a^{\phi(n)} \equiv 1 \pmod{n} \).</p>

    <h2 id="groups">Groups</h2>
    <p>A group is a set equipped with an operation that satisfies four properties: closure, associativity, the existence of an identity element, and the existence of inverses.</p>

    <h2 id="generators">Generators</h2>
    <p>A unit \( g \in \mathbb{Z}_n^* \) is called a generator or primitive root of \( \mathbb{Z}_n^* \) if for every \( a \in \mathbb{Z}_n^* \), we have \( g^k = a \) for some integer \( k \). In other words, if we start with \( g \) and keep multiplying by \( g \), eventually we see every element.<br> The order of a unit \( a \in \mathbb{Z}_n^* \) is defined as the smallest integer \(k\) for which \( a^k \equiv 1 \pmod{n} \).
    <p><strong>Theorem:</strong> The order of a generator \( g \in \mathbb{Z}_n^* \) modulo n is  \(\phi(n)\).<br><strong>Proof:</strong>There are \(\phi(n)\) elements in \(\mathbb{Z}_n^* \). We will show that \( g^1,\dots, g^{\phi(n)-1}\) are incongruent modulo n. If otherwise, \(\exists\) \(k \in \mathbb{Z}_n^*\) that is incongruent to all of \(g^1,\dots, g^{\phi(n)-1}\). Since g is a generator \(\exists\) \( r\) such that \(g^r \equiv k \pmod{n}\).<br>\(r = q\phi(n)+m\) where \(m \in \{1,\dots, {\phi(n)-1}\}\)<br>By <strong>Euler's Theorem</strong> we have that \(g^{\phi(n)} \equiv 1 \pmod{n}\). So \(g^{m} \equiv k \pmod{n}\) where \(m \in \{1,\dots, {\phi(n)-1}\}\).<br>This is a contradiction to the fact that \(k\) is incongruent to all of \(g^1,\dots, g^{\phi(n)-1}\). Hence all of \( g^1,\dots, g^{\phi(n)-1}\) are incongruent to each other. So \(\phi(n)\) is the smallest number \(a\) such that \(g^a \equiv 1 \pmod{n}\). Thus order of g is \(\phi(n)\).</p>

    <h2 id="quadratic-residue">Quadratic Residue</h2>
    <h2 id="legendre-symbol">Legendre Symbol</h2>
    <h2 id="jacobi-symbol">Jacobi Symbol</h2>
    <h2 id="algorithm-analysis">The Algorithm and Its Analysis</h2>

</body>
</html>
